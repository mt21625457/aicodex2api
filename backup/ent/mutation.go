// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/Wei-Shaw/sub2api/backup/ent/backupjob"
	"github.com/Wei-Shaw/sub2api/backup/ent/backupjobevent"
	"github.com/Wei-Shaw/sub2api/backup/ent/backups3config"
	"github.com/Wei-Shaw/sub2api/backup/ent/backupsetting"
	"github.com/Wei-Shaw/sub2api/backup/ent/backupsourceconfig"
	"github.com/Wei-Shaw/sub2api/backup/ent/predicate"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBackupJob          = "BackupJob"
	TypeBackupJobEvent     = "BackupJobEvent"
	TypeBackupS3Config     = "BackupS3Config"
	TypeBackupSetting      = "BackupSetting"
	TypeBackupSourceConfig = "BackupSourceConfig"
)

// BackupJobMutation represents an operation that mutates the BackupJob nodes in the graph.
type BackupJobMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	job_id                 *string
	backup_type            *backupjob.BackupType
	status                 *backupjob.Status
	triggered_by           *string
	idempotency_key        *string
	upload_to_s3           *bool
	s3_profile_id          *string
	postgres_profile_id    *string
	redis_profile_id       *string
	started_at             *time.Time
	finished_at            *time.Time
	error_message          *string
	artifact_local_path    *string
	artifact_size_bytes    *int64
	addartifact_size_bytes *int64
	artifact_sha256        *string
	s3_bucket              *string
	s3_key                 *string
	s3_etag                *string
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	events                 map[int]struct{}
	removedevents          map[int]struct{}
	clearedevents          bool
	done                   bool
	oldValue               func(context.Context) (*BackupJob, error)
	predicates             []predicate.BackupJob
}

var _ ent.Mutation = (*BackupJobMutation)(nil)

// backupjobOption allows management of the mutation configuration using functional options.
type backupjobOption func(*BackupJobMutation)

// newBackupJobMutation creates new mutation for the BackupJob entity.
func newBackupJobMutation(c config, op Op, opts ...backupjobOption) *BackupJobMutation {
	m := &BackupJobMutation{
		config:        c,
		op:            op,
		typ:           TypeBackupJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBackupJobID sets the ID field of the mutation.
func withBackupJobID(id int) backupjobOption {
	return func(m *BackupJobMutation) {
		var (
			err   error
			once  sync.Once
			value *BackupJob
		)
		m.oldValue = func(ctx context.Context) (*BackupJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BackupJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBackupJob sets the old BackupJob of the mutation.
func withBackupJob(node *BackupJob) backupjobOption {
	return func(m *BackupJobMutation) {
		m.oldValue = func(context.Context) (*BackupJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BackupJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BackupJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BackupJobMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BackupJobMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BackupJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJobID sets the "job_id" field.
func (m *BackupJobMutation) SetJobID(s string) {
	m.job_id = &s
}

// JobID returns the value of the "job_id" field in the mutation.
func (m *BackupJobMutation) JobID() (r string, exists bool) {
	v := m.job_id
	if v == nil {
		return
	}
	return *v, true
}

// OldJobID returns the old "job_id" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldJobID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobID: %w", err)
	}
	return oldValue.JobID, nil
}

// ResetJobID resets all changes to the "job_id" field.
func (m *BackupJobMutation) ResetJobID() {
	m.job_id = nil
}

// SetBackupType sets the "backup_type" field.
func (m *BackupJobMutation) SetBackupType(bt backupjob.BackupType) {
	m.backup_type = &bt
}

// BackupType returns the value of the "backup_type" field in the mutation.
func (m *BackupJobMutation) BackupType() (r backupjob.BackupType, exists bool) {
	v := m.backup_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupType returns the old "backup_type" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldBackupType(ctx context.Context) (v backupjob.BackupType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupType: %w", err)
	}
	return oldValue.BackupType, nil
}

// ResetBackupType resets all changes to the "backup_type" field.
func (m *BackupJobMutation) ResetBackupType() {
	m.backup_type = nil
}

// SetStatus sets the "status" field.
func (m *BackupJobMutation) SetStatus(b backupjob.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BackupJobMutation) Status() (r backupjob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldStatus(ctx context.Context) (v backupjob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BackupJobMutation) ResetStatus() {
	m.status = nil
}

// SetTriggeredBy sets the "triggered_by" field.
func (m *BackupJobMutation) SetTriggeredBy(s string) {
	m.triggered_by = &s
}

// TriggeredBy returns the value of the "triggered_by" field in the mutation.
func (m *BackupJobMutation) TriggeredBy() (r string, exists bool) {
	v := m.triggered_by
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggeredBy returns the old "triggered_by" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldTriggeredBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggeredBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggeredBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggeredBy: %w", err)
	}
	return oldValue.TriggeredBy, nil
}

// ResetTriggeredBy resets all changes to the "triggered_by" field.
func (m *BackupJobMutation) ResetTriggeredBy() {
	m.triggered_by = nil
}

// SetIdempotencyKey sets the "idempotency_key" field.
func (m *BackupJobMutation) SetIdempotencyKey(s string) {
	m.idempotency_key = &s
}

// IdempotencyKey returns the value of the "idempotency_key" field in the mutation.
func (m *BackupJobMutation) IdempotencyKey() (r string, exists bool) {
	v := m.idempotency_key
	if v == nil {
		return
	}
	return *v, true
}

// OldIdempotencyKey returns the old "idempotency_key" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldIdempotencyKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdempotencyKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdempotencyKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdempotencyKey: %w", err)
	}
	return oldValue.IdempotencyKey, nil
}

// ClearIdempotencyKey clears the value of the "idempotency_key" field.
func (m *BackupJobMutation) ClearIdempotencyKey() {
	m.idempotency_key = nil
	m.clearedFields[backupjob.FieldIdempotencyKey] = struct{}{}
}

// IdempotencyKeyCleared returns if the "idempotency_key" field was cleared in this mutation.
func (m *BackupJobMutation) IdempotencyKeyCleared() bool {
	_, ok := m.clearedFields[backupjob.FieldIdempotencyKey]
	return ok
}

// ResetIdempotencyKey resets all changes to the "idempotency_key" field.
func (m *BackupJobMutation) ResetIdempotencyKey() {
	m.idempotency_key = nil
	delete(m.clearedFields, backupjob.FieldIdempotencyKey)
}

// SetUploadToS3 sets the "upload_to_s3" field.
func (m *BackupJobMutation) SetUploadToS3(b bool) {
	m.upload_to_s3 = &b
}

// UploadToS3 returns the value of the "upload_to_s3" field in the mutation.
func (m *BackupJobMutation) UploadToS3() (r bool, exists bool) {
	v := m.upload_to_s3
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadToS3 returns the old "upload_to_s3" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldUploadToS3(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadToS3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadToS3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadToS3: %w", err)
	}
	return oldValue.UploadToS3, nil
}

// ResetUploadToS3 resets all changes to the "upload_to_s3" field.
func (m *BackupJobMutation) ResetUploadToS3() {
	m.upload_to_s3 = nil
}

// SetS3ProfileID sets the "s3_profile_id" field.
func (m *BackupJobMutation) SetS3ProfileID(s string) {
	m.s3_profile_id = &s
}

// S3ProfileID returns the value of the "s3_profile_id" field in the mutation.
func (m *BackupJobMutation) S3ProfileID() (r string, exists bool) {
	v := m.s3_profile_id
	if v == nil {
		return
	}
	return *v, true
}

// OldS3ProfileID returns the old "s3_profile_id" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldS3ProfileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldS3ProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldS3ProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldS3ProfileID: %w", err)
	}
	return oldValue.S3ProfileID, nil
}

// ClearS3ProfileID clears the value of the "s3_profile_id" field.
func (m *BackupJobMutation) ClearS3ProfileID() {
	m.s3_profile_id = nil
	m.clearedFields[backupjob.FieldS3ProfileID] = struct{}{}
}

// S3ProfileIDCleared returns if the "s3_profile_id" field was cleared in this mutation.
func (m *BackupJobMutation) S3ProfileIDCleared() bool {
	_, ok := m.clearedFields[backupjob.FieldS3ProfileID]
	return ok
}

// ResetS3ProfileID resets all changes to the "s3_profile_id" field.
func (m *BackupJobMutation) ResetS3ProfileID() {
	m.s3_profile_id = nil
	delete(m.clearedFields, backupjob.FieldS3ProfileID)
}

// SetPostgresProfileID sets the "postgres_profile_id" field.
func (m *BackupJobMutation) SetPostgresProfileID(s string) {
	m.postgres_profile_id = &s
}

// PostgresProfileID returns the value of the "postgres_profile_id" field in the mutation.
func (m *BackupJobMutation) PostgresProfileID() (r string, exists bool) {
	v := m.postgres_profile_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPostgresProfileID returns the old "postgres_profile_id" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldPostgresProfileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostgresProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostgresProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostgresProfileID: %w", err)
	}
	return oldValue.PostgresProfileID, nil
}

// ClearPostgresProfileID clears the value of the "postgres_profile_id" field.
func (m *BackupJobMutation) ClearPostgresProfileID() {
	m.postgres_profile_id = nil
	m.clearedFields[backupjob.FieldPostgresProfileID] = struct{}{}
}

// PostgresProfileIDCleared returns if the "postgres_profile_id" field was cleared in this mutation.
func (m *BackupJobMutation) PostgresProfileIDCleared() bool {
	_, ok := m.clearedFields[backupjob.FieldPostgresProfileID]
	return ok
}

// ResetPostgresProfileID resets all changes to the "postgres_profile_id" field.
func (m *BackupJobMutation) ResetPostgresProfileID() {
	m.postgres_profile_id = nil
	delete(m.clearedFields, backupjob.FieldPostgresProfileID)
}

// SetRedisProfileID sets the "redis_profile_id" field.
func (m *BackupJobMutation) SetRedisProfileID(s string) {
	m.redis_profile_id = &s
}

// RedisProfileID returns the value of the "redis_profile_id" field in the mutation.
func (m *BackupJobMutation) RedisProfileID() (r string, exists bool) {
	v := m.redis_profile_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRedisProfileID returns the old "redis_profile_id" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldRedisProfileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedisProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedisProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedisProfileID: %w", err)
	}
	return oldValue.RedisProfileID, nil
}

// ClearRedisProfileID clears the value of the "redis_profile_id" field.
func (m *BackupJobMutation) ClearRedisProfileID() {
	m.redis_profile_id = nil
	m.clearedFields[backupjob.FieldRedisProfileID] = struct{}{}
}

// RedisProfileIDCleared returns if the "redis_profile_id" field was cleared in this mutation.
func (m *BackupJobMutation) RedisProfileIDCleared() bool {
	_, ok := m.clearedFields[backupjob.FieldRedisProfileID]
	return ok
}

// ResetRedisProfileID resets all changes to the "redis_profile_id" field.
func (m *BackupJobMutation) ResetRedisProfileID() {
	m.redis_profile_id = nil
	delete(m.clearedFields, backupjob.FieldRedisProfileID)
}

// SetStartedAt sets the "started_at" field.
func (m *BackupJobMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *BackupJobMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *BackupJobMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[backupjob.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *BackupJobMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[backupjob.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *BackupJobMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, backupjob.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *BackupJobMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *BackupJobMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *BackupJobMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[backupjob.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *BackupJobMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[backupjob.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *BackupJobMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, backupjob.FieldFinishedAt)
}

// SetErrorMessage sets the "error_message" field.
func (m *BackupJobMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *BackupJobMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *BackupJobMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[backupjob.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *BackupJobMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[backupjob.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *BackupJobMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, backupjob.FieldErrorMessage)
}

// SetArtifactLocalPath sets the "artifact_local_path" field.
func (m *BackupJobMutation) SetArtifactLocalPath(s string) {
	m.artifact_local_path = &s
}

// ArtifactLocalPath returns the value of the "artifact_local_path" field in the mutation.
func (m *BackupJobMutation) ArtifactLocalPath() (r string, exists bool) {
	v := m.artifact_local_path
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactLocalPath returns the old "artifact_local_path" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldArtifactLocalPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactLocalPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactLocalPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactLocalPath: %w", err)
	}
	return oldValue.ArtifactLocalPath, nil
}

// ClearArtifactLocalPath clears the value of the "artifact_local_path" field.
func (m *BackupJobMutation) ClearArtifactLocalPath() {
	m.artifact_local_path = nil
	m.clearedFields[backupjob.FieldArtifactLocalPath] = struct{}{}
}

// ArtifactLocalPathCleared returns if the "artifact_local_path" field was cleared in this mutation.
func (m *BackupJobMutation) ArtifactLocalPathCleared() bool {
	_, ok := m.clearedFields[backupjob.FieldArtifactLocalPath]
	return ok
}

// ResetArtifactLocalPath resets all changes to the "artifact_local_path" field.
func (m *BackupJobMutation) ResetArtifactLocalPath() {
	m.artifact_local_path = nil
	delete(m.clearedFields, backupjob.FieldArtifactLocalPath)
}

// SetArtifactSizeBytes sets the "artifact_size_bytes" field.
func (m *BackupJobMutation) SetArtifactSizeBytes(i int64) {
	m.artifact_size_bytes = &i
	m.addartifact_size_bytes = nil
}

// ArtifactSizeBytes returns the value of the "artifact_size_bytes" field in the mutation.
func (m *BackupJobMutation) ArtifactSizeBytes() (r int64, exists bool) {
	v := m.artifact_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactSizeBytes returns the old "artifact_size_bytes" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldArtifactSizeBytes(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactSizeBytes: %w", err)
	}
	return oldValue.ArtifactSizeBytes, nil
}

// AddArtifactSizeBytes adds i to the "artifact_size_bytes" field.
func (m *BackupJobMutation) AddArtifactSizeBytes(i int64) {
	if m.addartifact_size_bytes != nil {
		*m.addartifact_size_bytes += i
	} else {
		m.addartifact_size_bytes = &i
	}
}

// AddedArtifactSizeBytes returns the value that was added to the "artifact_size_bytes" field in this mutation.
func (m *BackupJobMutation) AddedArtifactSizeBytes() (r int64, exists bool) {
	v := m.addartifact_size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearArtifactSizeBytes clears the value of the "artifact_size_bytes" field.
func (m *BackupJobMutation) ClearArtifactSizeBytes() {
	m.artifact_size_bytes = nil
	m.addartifact_size_bytes = nil
	m.clearedFields[backupjob.FieldArtifactSizeBytes] = struct{}{}
}

// ArtifactSizeBytesCleared returns if the "artifact_size_bytes" field was cleared in this mutation.
func (m *BackupJobMutation) ArtifactSizeBytesCleared() bool {
	_, ok := m.clearedFields[backupjob.FieldArtifactSizeBytes]
	return ok
}

// ResetArtifactSizeBytes resets all changes to the "artifact_size_bytes" field.
func (m *BackupJobMutation) ResetArtifactSizeBytes() {
	m.artifact_size_bytes = nil
	m.addartifact_size_bytes = nil
	delete(m.clearedFields, backupjob.FieldArtifactSizeBytes)
}

// SetArtifactSha256 sets the "artifact_sha256" field.
func (m *BackupJobMutation) SetArtifactSha256(s string) {
	m.artifact_sha256 = &s
}

// ArtifactSha256 returns the value of the "artifact_sha256" field in the mutation.
func (m *BackupJobMutation) ArtifactSha256() (r string, exists bool) {
	v := m.artifact_sha256
	if v == nil {
		return
	}
	return *v, true
}

// OldArtifactSha256 returns the old "artifact_sha256" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldArtifactSha256(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtifactSha256 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtifactSha256 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtifactSha256: %w", err)
	}
	return oldValue.ArtifactSha256, nil
}

// ClearArtifactSha256 clears the value of the "artifact_sha256" field.
func (m *BackupJobMutation) ClearArtifactSha256() {
	m.artifact_sha256 = nil
	m.clearedFields[backupjob.FieldArtifactSha256] = struct{}{}
}

// ArtifactSha256Cleared returns if the "artifact_sha256" field was cleared in this mutation.
func (m *BackupJobMutation) ArtifactSha256Cleared() bool {
	_, ok := m.clearedFields[backupjob.FieldArtifactSha256]
	return ok
}

// ResetArtifactSha256 resets all changes to the "artifact_sha256" field.
func (m *BackupJobMutation) ResetArtifactSha256() {
	m.artifact_sha256 = nil
	delete(m.clearedFields, backupjob.FieldArtifactSha256)
}

// SetS3Bucket sets the "s3_bucket" field.
func (m *BackupJobMutation) SetS3Bucket(s string) {
	m.s3_bucket = &s
}

// S3Bucket returns the value of the "s3_bucket" field in the mutation.
func (m *BackupJobMutation) S3Bucket() (r string, exists bool) {
	v := m.s3_bucket
	if v == nil {
		return
	}
	return *v, true
}

// OldS3Bucket returns the old "s3_bucket" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldS3Bucket(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldS3Bucket is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldS3Bucket requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldS3Bucket: %w", err)
	}
	return oldValue.S3Bucket, nil
}

// ClearS3Bucket clears the value of the "s3_bucket" field.
func (m *BackupJobMutation) ClearS3Bucket() {
	m.s3_bucket = nil
	m.clearedFields[backupjob.FieldS3Bucket] = struct{}{}
}

// S3BucketCleared returns if the "s3_bucket" field was cleared in this mutation.
func (m *BackupJobMutation) S3BucketCleared() bool {
	_, ok := m.clearedFields[backupjob.FieldS3Bucket]
	return ok
}

// ResetS3Bucket resets all changes to the "s3_bucket" field.
func (m *BackupJobMutation) ResetS3Bucket() {
	m.s3_bucket = nil
	delete(m.clearedFields, backupjob.FieldS3Bucket)
}

// SetS3Key sets the "s3_key" field.
func (m *BackupJobMutation) SetS3Key(s string) {
	m.s3_key = &s
}

// S3Key returns the value of the "s3_key" field in the mutation.
func (m *BackupJobMutation) S3Key() (r string, exists bool) {
	v := m.s3_key
	if v == nil {
		return
	}
	return *v, true
}

// OldS3Key returns the old "s3_key" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldS3Key(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldS3Key is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldS3Key requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldS3Key: %w", err)
	}
	return oldValue.S3Key, nil
}

// ClearS3Key clears the value of the "s3_key" field.
func (m *BackupJobMutation) ClearS3Key() {
	m.s3_key = nil
	m.clearedFields[backupjob.FieldS3Key] = struct{}{}
}

// S3KeyCleared returns if the "s3_key" field was cleared in this mutation.
func (m *BackupJobMutation) S3KeyCleared() bool {
	_, ok := m.clearedFields[backupjob.FieldS3Key]
	return ok
}

// ResetS3Key resets all changes to the "s3_key" field.
func (m *BackupJobMutation) ResetS3Key() {
	m.s3_key = nil
	delete(m.clearedFields, backupjob.FieldS3Key)
}

// SetS3Etag sets the "s3_etag" field.
func (m *BackupJobMutation) SetS3Etag(s string) {
	m.s3_etag = &s
}

// S3Etag returns the value of the "s3_etag" field in the mutation.
func (m *BackupJobMutation) S3Etag() (r string, exists bool) {
	v := m.s3_etag
	if v == nil {
		return
	}
	return *v, true
}

// OldS3Etag returns the old "s3_etag" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldS3Etag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldS3Etag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldS3Etag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldS3Etag: %w", err)
	}
	return oldValue.S3Etag, nil
}

// ClearS3Etag clears the value of the "s3_etag" field.
func (m *BackupJobMutation) ClearS3Etag() {
	m.s3_etag = nil
	m.clearedFields[backupjob.FieldS3Etag] = struct{}{}
}

// S3EtagCleared returns if the "s3_etag" field was cleared in this mutation.
func (m *BackupJobMutation) S3EtagCleared() bool {
	_, ok := m.clearedFields[backupjob.FieldS3Etag]
	return ok
}

// ResetS3Etag resets all changes to the "s3_etag" field.
func (m *BackupJobMutation) ResetS3Etag() {
	m.s3_etag = nil
	delete(m.clearedFields, backupjob.FieldS3Etag)
}

// SetCreatedAt sets the "created_at" field.
func (m *BackupJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BackupJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BackupJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BackupJobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BackupJobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BackupJob entity.
// If the BackupJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BackupJobMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddEventIDs adds the "events" edge to the BackupJobEvent entity by ids.
func (m *BackupJobMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the BackupJobEvent entity.
func (m *BackupJobMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the BackupJobEvent entity was cleared.
func (m *BackupJobMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the BackupJobEvent entity by IDs.
func (m *BackupJobMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the BackupJobEvent entity.
func (m *BackupJobMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *BackupJobMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *BackupJobMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the BackupJobMutation builder.
func (m *BackupJobMutation) Where(ps ...predicate.BackupJob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BackupJobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BackupJobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BackupJob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BackupJobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BackupJobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BackupJob).
func (m *BackupJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BackupJobMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.job_id != nil {
		fields = append(fields, backupjob.FieldJobID)
	}
	if m.backup_type != nil {
		fields = append(fields, backupjob.FieldBackupType)
	}
	if m.status != nil {
		fields = append(fields, backupjob.FieldStatus)
	}
	if m.triggered_by != nil {
		fields = append(fields, backupjob.FieldTriggeredBy)
	}
	if m.idempotency_key != nil {
		fields = append(fields, backupjob.FieldIdempotencyKey)
	}
	if m.upload_to_s3 != nil {
		fields = append(fields, backupjob.FieldUploadToS3)
	}
	if m.s3_profile_id != nil {
		fields = append(fields, backupjob.FieldS3ProfileID)
	}
	if m.postgres_profile_id != nil {
		fields = append(fields, backupjob.FieldPostgresProfileID)
	}
	if m.redis_profile_id != nil {
		fields = append(fields, backupjob.FieldRedisProfileID)
	}
	if m.started_at != nil {
		fields = append(fields, backupjob.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, backupjob.FieldFinishedAt)
	}
	if m.error_message != nil {
		fields = append(fields, backupjob.FieldErrorMessage)
	}
	if m.artifact_local_path != nil {
		fields = append(fields, backupjob.FieldArtifactLocalPath)
	}
	if m.artifact_size_bytes != nil {
		fields = append(fields, backupjob.FieldArtifactSizeBytes)
	}
	if m.artifact_sha256 != nil {
		fields = append(fields, backupjob.FieldArtifactSha256)
	}
	if m.s3_bucket != nil {
		fields = append(fields, backupjob.FieldS3Bucket)
	}
	if m.s3_key != nil {
		fields = append(fields, backupjob.FieldS3Key)
	}
	if m.s3_etag != nil {
		fields = append(fields, backupjob.FieldS3Etag)
	}
	if m.created_at != nil {
		fields = append(fields, backupjob.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, backupjob.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BackupJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case backupjob.FieldJobID:
		return m.JobID()
	case backupjob.FieldBackupType:
		return m.BackupType()
	case backupjob.FieldStatus:
		return m.Status()
	case backupjob.FieldTriggeredBy:
		return m.TriggeredBy()
	case backupjob.FieldIdempotencyKey:
		return m.IdempotencyKey()
	case backupjob.FieldUploadToS3:
		return m.UploadToS3()
	case backupjob.FieldS3ProfileID:
		return m.S3ProfileID()
	case backupjob.FieldPostgresProfileID:
		return m.PostgresProfileID()
	case backupjob.FieldRedisProfileID:
		return m.RedisProfileID()
	case backupjob.FieldStartedAt:
		return m.StartedAt()
	case backupjob.FieldFinishedAt:
		return m.FinishedAt()
	case backupjob.FieldErrorMessage:
		return m.ErrorMessage()
	case backupjob.FieldArtifactLocalPath:
		return m.ArtifactLocalPath()
	case backupjob.FieldArtifactSizeBytes:
		return m.ArtifactSizeBytes()
	case backupjob.FieldArtifactSha256:
		return m.ArtifactSha256()
	case backupjob.FieldS3Bucket:
		return m.S3Bucket()
	case backupjob.FieldS3Key:
		return m.S3Key()
	case backupjob.FieldS3Etag:
		return m.S3Etag()
	case backupjob.FieldCreatedAt:
		return m.CreatedAt()
	case backupjob.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BackupJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case backupjob.FieldJobID:
		return m.OldJobID(ctx)
	case backupjob.FieldBackupType:
		return m.OldBackupType(ctx)
	case backupjob.FieldStatus:
		return m.OldStatus(ctx)
	case backupjob.FieldTriggeredBy:
		return m.OldTriggeredBy(ctx)
	case backupjob.FieldIdempotencyKey:
		return m.OldIdempotencyKey(ctx)
	case backupjob.FieldUploadToS3:
		return m.OldUploadToS3(ctx)
	case backupjob.FieldS3ProfileID:
		return m.OldS3ProfileID(ctx)
	case backupjob.FieldPostgresProfileID:
		return m.OldPostgresProfileID(ctx)
	case backupjob.FieldRedisProfileID:
		return m.OldRedisProfileID(ctx)
	case backupjob.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case backupjob.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case backupjob.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case backupjob.FieldArtifactLocalPath:
		return m.OldArtifactLocalPath(ctx)
	case backupjob.FieldArtifactSizeBytes:
		return m.OldArtifactSizeBytes(ctx)
	case backupjob.FieldArtifactSha256:
		return m.OldArtifactSha256(ctx)
	case backupjob.FieldS3Bucket:
		return m.OldS3Bucket(ctx)
	case backupjob.FieldS3Key:
		return m.OldS3Key(ctx)
	case backupjob.FieldS3Etag:
		return m.OldS3Etag(ctx)
	case backupjob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case backupjob.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BackupJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackupJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case backupjob.FieldJobID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobID(v)
		return nil
	case backupjob.FieldBackupType:
		v, ok := value.(backupjob.BackupType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupType(v)
		return nil
	case backupjob.FieldStatus:
		v, ok := value.(backupjob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case backupjob.FieldTriggeredBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggeredBy(v)
		return nil
	case backupjob.FieldIdempotencyKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdempotencyKey(v)
		return nil
	case backupjob.FieldUploadToS3:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadToS3(v)
		return nil
	case backupjob.FieldS3ProfileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetS3ProfileID(v)
		return nil
	case backupjob.FieldPostgresProfileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostgresProfileID(v)
		return nil
	case backupjob.FieldRedisProfileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedisProfileID(v)
		return nil
	case backupjob.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case backupjob.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case backupjob.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case backupjob.FieldArtifactLocalPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactLocalPath(v)
		return nil
	case backupjob.FieldArtifactSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactSizeBytes(v)
		return nil
	case backupjob.FieldArtifactSha256:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtifactSha256(v)
		return nil
	case backupjob.FieldS3Bucket:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetS3Bucket(v)
		return nil
	case backupjob.FieldS3Key:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetS3Key(v)
		return nil
	case backupjob.FieldS3Etag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetS3Etag(v)
		return nil
	case backupjob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case backupjob.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BackupJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BackupJobMutation) AddedFields() []string {
	var fields []string
	if m.addartifact_size_bytes != nil {
		fields = append(fields, backupjob.FieldArtifactSizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BackupJobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case backupjob.FieldArtifactSizeBytes:
		return m.AddedArtifactSizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackupJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case backupjob.FieldArtifactSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddArtifactSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown BackupJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BackupJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(backupjob.FieldIdempotencyKey) {
		fields = append(fields, backupjob.FieldIdempotencyKey)
	}
	if m.FieldCleared(backupjob.FieldS3ProfileID) {
		fields = append(fields, backupjob.FieldS3ProfileID)
	}
	if m.FieldCleared(backupjob.FieldPostgresProfileID) {
		fields = append(fields, backupjob.FieldPostgresProfileID)
	}
	if m.FieldCleared(backupjob.FieldRedisProfileID) {
		fields = append(fields, backupjob.FieldRedisProfileID)
	}
	if m.FieldCleared(backupjob.FieldStartedAt) {
		fields = append(fields, backupjob.FieldStartedAt)
	}
	if m.FieldCleared(backupjob.FieldFinishedAt) {
		fields = append(fields, backupjob.FieldFinishedAt)
	}
	if m.FieldCleared(backupjob.FieldErrorMessage) {
		fields = append(fields, backupjob.FieldErrorMessage)
	}
	if m.FieldCleared(backupjob.FieldArtifactLocalPath) {
		fields = append(fields, backupjob.FieldArtifactLocalPath)
	}
	if m.FieldCleared(backupjob.FieldArtifactSizeBytes) {
		fields = append(fields, backupjob.FieldArtifactSizeBytes)
	}
	if m.FieldCleared(backupjob.FieldArtifactSha256) {
		fields = append(fields, backupjob.FieldArtifactSha256)
	}
	if m.FieldCleared(backupjob.FieldS3Bucket) {
		fields = append(fields, backupjob.FieldS3Bucket)
	}
	if m.FieldCleared(backupjob.FieldS3Key) {
		fields = append(fields, backupjob.FieldS3Key)
	}
	if m.FieldCleared(backupjob.FieldS3Etag) {
		fields = append(fields, backupjob.FieldS3Etag)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BackupJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BackupJobMutation) ClearField(name string) error {
	switch name {
	case backupjob.FieldIdempotencyKey:
		m.ClearIdempotencyKey()
		return nil
	case backupjob.FieldS3ProfileID:
		m.ClearS3ProfileID()
		return nil
	case backupjob.FieldPostgresProfileID:
		m.ClearPostgresProfileID()
		return nil
	case backupjob.FieldRedisProfileID:
		m.ClearRedisProfileID()
		return nil
	case backupjob.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case backupjob.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	case backupjob.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case backupjob.FieldArtifactLocalPath:
		m.ClearArtifactLocalPath()
		return nil
	case backupjob.FieldArtifactSizeBytes:
		m.ClearArtifactSizeBytes()
		return nil
	case backupjob.FieldArtifactSha256:
		m.ClearArtifactSha256()
		return nil
	case backupjob.FieldS3Bucket:
		m.ClearS3Bucket()
		return nil
	case backupjob.FieldS3Key:
		m.ClearS3Key()
		return nil
	case backupjob.FieldS3Etag:
		m.ClearS3Etag()
		return nil
	}
	return fmt.Errorf("unknown BackupJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BackupJobMutation) ResetField(name string) error {
	switch name {
	case backupjob.FieldJobID:
		m.ResetJobID()
		return nil
	case backupjob.FieldBackupType:
		m.ResetBackupType()
		return nil
	case backupjob.FieldStatus:
		m.ResetStatus()
		return nil
	case backupjob.FieldTriggeredBy:
		m.ResetTriggeredBy()
		return nil
	case backupjob.FieldIdempotencyKey:
		m.ResetIdempotencyKey()
		return nil
	case backupjob.FieldUploadToS3:
		m.ResetUploadToS3()
		return nil
	case backupjob.FieldS3ProfileID:
		m.ResetS3ProfileID()
		return nil
	case backupjob.FieldPostgresProfileID:
		m.ResetPostgresProfileID()
		return nil
	case backupjob.FieldRedisProfileID:
		m.ResetRedisProfileID()
		return nil
	case backupjob.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case backupjob.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case backupjob.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case backupjob.FieldArtifactLocalPath:
		m.ResetArtifactLocalPath()
		return nil
	case backupjob.FieldArtifactSizeBytes:
		m.ResetArtifactSizeBytes()
		return nil
	case backupjob.FieldArtifactSha256:
		m.ResetArtifactSha256()
		return nil
	case backupjob.FieldS3Bucket:
		m.ResetS3Bucket()
		return nil
	case backupjob.FieldS3Key:
		m.ResetS3Key()
		return nil
	case backupjob.FieldS3Etag:
		m.ResetS3Etag()
		return nil
	case backupjob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case backupjob.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BackupJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BackupJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.events != nil {
		edges = append(edges, backupjob.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BackupJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case backupjob.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BackupJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedevents != nil {
		edges = append(edges, backupjob.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BackupJobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case backupjob.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BackupJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevents {
		edges = append(edges, backupjob.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BackupJobMutation) EdgeCleared(name string) bool {
	switch name {
	case backupjob.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BackupJobMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BackupJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BackupJobMutation) ResetEdge(name string) error {
	switch name {
	case backupjob.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown BackupJob edge %s", name)
}

// BackupJobEventMutation represents an operation that mutates the BackupJobEvent nodes in the graph.
type BackupJobEventMutation struct {
	config
	op            Op
	typ           string
	id            *int
	level         *backupjobevent.Level
	event_type    *string
	message       *string
	payload       *string
	event_time    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	job           *int
	clearedjob    bool
	done          bool
	oldValue      func(context.Context) (*BackupJobEvent, error)
	predicates    []predicate.BackupJobEvent
}

var _ ent.Mutation = (*BackupJobEventMutation)(nil)

// backupjobeventOption allows management of the mutation configuration using functional options.
type backupjobeventOption func(*BackupJobEventMutation)

// newBackupJobEventMutation creates new mutation for the BackupJobEvent entity.
func newBackupJobEventMutation(c config, op Op, opts ...backupjobeventOption) *BackupJobEventMutation {
	m := &BackupJobEventMutation{
		config:        c,
		op:            op,
		typ:           TypeBackupJobEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBackupJobEventID sets the ID field of the mutation.
func withBackupJobEventID(id int) backupjobeventOption {
	return func(m *BackupJobEventMutation) {
		var (
			err   error
			once  sync.Once
			value *BackupJobEvent
		)
		m.oldValue = func(ctx context.Context) (*BackupJobEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BackupJobEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBackupJobEvent sets the old BackupJobEvent of the mutation.
func withBackupJobEvent(node *BackupJobEvent) backupjobeventOption {
	return func(m *BackupJobEventMutation) {
		m.oldValue = func(context.Context) (*BackupJobEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BackupJobEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BackupJobEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BackupJobEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BackupJobEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BackupJobEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBackupJobID sets the "backup_job_id" field.
func (m *BackupJobEventMutation) SetBackupJobID(i int) {
	m.job = &i
}

// BackupJobID returns the value of the "backup_job_id" field in the mutation.
func (m *BackupJobEventMutation) BackupJobID() (r int, exists bool) {
	v := m.job
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupJobID returns the old "backup_job_id" field's value of the BackupJobEvent entity.
// If the BackupJobEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobEventMutation) OldBackupJobID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupJobID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupJobID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupJobID: %w", err)
	}
	return oldValue.BackupJobID, nil
}

// ResetBackupJobID resets all changes to the "backup_job_id" field.
func (m *BackupJobEventMutation) ResetBackupJobID() {
	m.job = nil
}

// SetLevel sets the "level" field.
func (m *BackupJobEventMutation) SetLevel(b backupjobevent.Level) {
	m.level = &b
}

// Level returns the value of the "level" field in the mutation.
func (m *BackupJobEventMutation) Level() (r backupjobevent.Level, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the BackupJobEvent entity.
// If the BackupJobEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobEventMutation) OldLevel(ctx context.Context) (v backupjobevent.Level, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ResetLevel resets all changes to the "level" field.
func (m *BackupJobEventMutation) ResetLevel() {
	m.level = nil
}

// SetEventType sets the "event_type" field.
func (m *BackupJobEventMutation) SetEventType(s string) {
	m.event_type = &s
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *BackupJobEventMutation) EventType() (r string, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the BackupJobEvent entity.
// If the BackupJobEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobEventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *BackupJobEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetMessage sets the "message" field.
func (m *BackupJobEventMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *BackupJobEventMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the BackupJobEvent entity.
// If the BackupJobEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobEventMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *BackupJobEventMutation) ResetMessage() {
	m.message = nil
}

// SetPayload sets the "payload" field.
func (m *BackupJobEventMutation) SetPayload(s string) {
	m.payload = &s
}

// Payload returns the value of the "payload" field in the mutation.
func (m *BackupJobEventMutation) Payload() (r string, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the BackupJobEvent entity.
// If the BackupJobEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobEventMutation) OldPayload(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ClearPayload clears the value of the "payload" field.
func (m *BackupJobEventMutation) ClearPayload() {
	m.payload = nil
	m.clearedFields[backupjobevent.FieldPayload] = struct{}{}
}

// PayloadCleared returns if the "payload" field was cleared in this mutation.
func (m *BackupJobEventMutation) PayloadCleared() bool {
	_, ok := m.clearedFields[backupjobevent.FieldPayload]
	return ok
}

// ResetPayload resets all changes to the "payload" field.
func (m *BackupJobEventMutation) ResetPayload() {
	m.payload = nil
	delete(m.clearedFields, backupjobevent.FieldPayload)
}

// SetEventTime sets the "event_time" field.
func (m *BackupJobEventMutation) SetEventTime(t time.Time) {
	m.event_time = &t
}

// EventTime returns the value of the "event_time" field in the mutation.
func (m *BackupJobEventMutation) EventTime() (r time.Time, exists bool) {
	v := m.event_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEventTime returns the old "event_time" field's value of the BackupJobEvent entity.
// If the BackupJobEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobEventMutation) OldEventTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventTime: %w", err)
	}
	return oldValue.EventTime, nil
}

// ResetEventTime resets all changes to the "event_time" field.
func (m *BackupJobEventMutation) ResetEventTime() {
	m.event_time = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BackupJobEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BackupJobEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BackupJobEvent entity.
// If the BackupJobEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupJobEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BackupJobEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetJobID sets the "job" edge to the BackupJob entity by id.
func (m *BackupJobEventMutation) SetJobID(id int) {
	m.job = &id
}

// ClearJob clears the "job" edge to the BackupJob entity.
func (m *BackupJobEventMutation) ClearJob() {
	m.clearedjob = true
	m.clearedFields[backupjobevent.FieldBackupJobID] = struct{}{}
}

// JobCleared reports if the "job" edge to the BackupJob entity was cleared.
func (m *BackupJobEventMutation) JobCleared() bool {
	return m.clearedjob
}

// JobID returns the "job" edge ID in the mutation.
func (m *BackupJobEventMutation) JobID() (id int, exists bool) {
	if m.job != nil {
		return *m.job, true
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *BackupJobEventMutation) JobIDs() (ids []int) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *BackupJobEventMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// Where appends a list predicates to the BackupJobEventMutation builder.
func (m *BackupJobEventMutation) Where(ps ...predicate.BackupJobEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BackupJobEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BackupJobEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BackupJobEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BackupJobEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BackupJobEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BackupJobEvent).
func (m *BackupJobEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BackupJobEventMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.job != nil {
		fields = append(fields, backupjobevent.FieldBackupJobID)
	}
	if m.level != nil {
		fields = append(fields, backupjobevent.FieldLevel)
	}
	if m.event_type != nil {
		fields = append(fields, backupjobevent.FieldEventType)
	}
	if m.message != nil {
		fields = append(fields, backupjobevent.FieldMessage)
	}
	if m.payload != nil {
		fields = append(fields, backupjobevent.FieldPayload)
	}
	if m.event_time != nil {
		fields = append(fields, backupjobevent.FieldEventTime)
	}
	if m.created_at != nil {
		fields = append(fields, backupjobevent.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BackupJobEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case backupjobevent.FieldBackupJobID:
		return m.BackupJobID()
	case backupjobevent.FieldLevel:
		return m.Level()
	case backupjobevent.FieldEventType:
		return m.EventType()
	case backupjobevent.FieldMessage:
		return m.Message()
	case backupjobevent.FieldPayload:
		return m.Payload()
	case backupjobevent.FieldEventTime:
		return m.EventTime()
	case backupjobevent.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BackupJobEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case backupjobevent.FieldBackupJobID:
		return m.OldBackupJobID(ctx)
	case backupjobevent.FieldLevel:
		return m.OldLevel(ctx)
	case backupjobevent.FieldEventType:
		return m.OldEventType(ctx)
	case backupjobevent.FieldMessage:
		return m.OldMessage(ctx)
	case backupjobevent.FieldPayload:
		return m.OldPayload(ctx)
	case backupjobevent.FieldEventTime:
		return m.OldEventTime(ctx)
	case backupjobevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BackupJobEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackupJobEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case backupjobevent.FieldBackupJobID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupJobID(v)
		return nil
	case backupjobevent.FieldLevel:
		v, ok := value.(backupjobevent.Level)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case backupjobevent.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case backupjobevent.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case backupjobevent.FieldPayload:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case backupjobevent.FieldEventTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventTime(v)
		return nil
	case backupjobevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BackupJobEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BackupJobEventMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BackupJobEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackupJobEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BackupJobEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BackupJobEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(backupjobevent.FieldPayload) {
		fields = append(fields, backupjobevent.FieldPayload)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BackupJobEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BackupJobEventMutation) ClearField(name string) error {
	switch name {
	case backupjobevent.FieldPayload:
		m.ClearPayload()
		return nil
	}
	return fmt.Errorf("unknown BackupJobEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BackupJobEventMutation) ResetField(name string) error {
	switch name {
	case backupjobevent.FieldBackupJobID:
		m.ResetBackupJobID()
		return nil
	case backupjobevent.FieldLevel:
		m.ResetLevel()
		return nil
	case backupjobevent.FieldEventType:
		m.ResetEventType()
		return nil
	case backupjobevent.FieldMessage:
		m.ResetMessage()
		return nil
	case backupjobevent.FieldPayload:
		m.ResetPayload()
		return nil
	case backupjobevent.FieldEventTime:
		m.ResetEventTime()
		return nil
	case backupjobevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown BackupJobEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BackupJobEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.job != nil {
		edges = append(edges, backupjobevent.EdgeJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BackupJobEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case backupjobevent.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BackupJobEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BackupJobEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BackupJobEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedjob {
		edges = append(edges, backupjobevent.EdgeJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BackupJobEventMutation) EdgeCleared(name string) bool {
	switch name {
	case backupjobevent.EdgeJob:
		return m.clearedjob
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BackupJobEventMutation) ClearEdge(name string) error {
	switch name {
	case backupjobevent.EdgeJob:
		m.ClearJob()
		return nil
	}
	return fmt.Errorf("unknown BackupJobEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BackupJobEventMutation) ResetEdge(name string) error {
	switch name {
	case backupjobevent.EdgeJob:
		m.ResetJob()
		return nil
	}
	return fmt.Errorf("unknown BackupJobEvent edge %s", name)
}

// BackupS3ConfigMutation represents an operation that mutates the BackupS3Config nodes in the graph.
type BackupS3ConfigMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	profile_id                  *string
	name                        *string
	is_active                   *bool
	enabled                     *bool
	endpoint                    *string
	region                      *string
	bucket                      *string
	access_key_id               *string
	secret_access_key_encrypted *string
	prefix                      *string
	force_path_style            *bool
	use_ssl                     *bool
	created_at                  *time.Time
	updated_at                  *time.Time
	clearedFields               map[string]struct{}
	done                        bool
	oldValue                    func(context.Context) (*BackupS3Config, error)
	predicates                  []predicate.BackupS3Config
}

var _ ent.Mutation = (*BackupS3ConfigMutation)(nil)

// backups3configOption allows management of the mutation configuration using functional options.
type backups3configOption func(*BackupS3ConfigMutation)

// newBackupS3ConfigMutation creates new mutation for the BackupS3Config entity.
func newBackupS3ConfigMutation(c config, op Op, opts ...backups3configOption) *BackupS3ConfigMutation {
	m := &BackupS3ConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeBackupS3Config,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBackupS3ConfigID sets the ID field of the mutation.
func withBackupS3ConfigID(id int) backups3configOption {
	return func(m *BackupS3ConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *BackupS3Config
		)
		m.oldValue = func(ctx context.Context) (*BackupS3Config, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BackupS3Config.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBackupS3Config sets the old BackupS3Config of the mutation.
func withBackupS3Config(node *BackupS3Config) backups3configOption {
	return func(m *BackupS3ConfigMutation) {
		m.oldValue = func(context.Context) (*BackupS3Config, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BackupS3ConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BackupS3ConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BackupS3ConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BackupS3ConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BackupS3Config.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProfileID sets the "profile_id" field.
func (m *BackupS3ConfigMutation) SetProfileID(s string) {
	m.profile_id = &s
}

// ProfileID returns the value of the "profile_id" field in the mutation.
func (m *BackupS3ConfigMutation) ProfileID() (r string, exists bool) {
	v := m.profile_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileID returns the old "profile_id" field's value of the BackupS3Config entity.
// If the BackupS3Config object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupS3ConfigMutation) OldProfileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileID: %w", err)
	}
	return oldValue.ProfileID, nil
}

// ResetProfileID resets all changes to the "profile_id" field.
func (m *BackupS3ConfigMutation) ResetProfileID() {
	m.profile_id = nil
}

// SetName sets the "name" field.
func (m *BackupS3ConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BackupS3ConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BackupS3Config entity.
// If the BackupS3Config object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupS3ConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BackupS3ConfigMutation) ResetName() {
	m.name = nil
}

// SetIsActive sets the "is_active" field.
func (m *BackupS3ConfigMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *BackupS3ConfigMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the BackupS3Config entity.
// If the BackupS3Config object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupS3ConfigMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *BackupS3ConfigMutation) ResetIsActive() {
	m.is_active = nil
}

// SetEnabled sets the "enabled" field.
func (m *BackupS3ConfigMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *BackupS3ConfigMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the BackupS3Config entity.
// If the BackupS3Config object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupS3ConfigMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *BackupS3ConfigMutation) ResetEnabled() {
	m.enabled = nil
}

// SetEndpoint sets the "endpoint" field.
func (m *BackupS3ConfigMutation) SetEndpoint(s string) {
	m.endpoint = &s
}

// Endpoint returns the value of the "endpoint" field in the mutation.
func (m *BackupS3ConfigMutation) Endpoint() (r string, exists bool) {
	v := m.endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldEndpoint returns the old "endpoint" field's value of the BackupS3Config entity.
// If the BackupS3Config object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupS3ConfigMutation) OldEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndpoint: %w", err)
	}
	return oldValue.Endpoint, nil
}

// ResetEndpoint resets all changes to the "endpoint" field.
func (m *BackupS3ConfigMutation) ResetEndpoint() {
	m.endpoint = nil
}

// SetRegion sets the "region" field.
func (m *BackupS3ConfigMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *BackupS3ConfigMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the BackupS3Config entity.
// If the BackupS3Config object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupS3ConfigMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ResetRegion resets all changes to the "region" field.
func (m *BackupS3ConfigMutation) ResetRegion() {
	m.region = nil
}

// SetBucket sets the "bucket" field.
func (m *BackupS3ConfigMutation) SetBucket(s string) {
	m.bucket = &s
}

// Bucket returns the value of the "bucket" field in the mutation.
func (m *BackupS3ConfigMutation) Bucket() (r string, exists bool) {
	v := m.bucket
	if v == nil {
		return
	}
	return *v, true
}

// OldBucket returns the old "bucket" field's value of the BackupS3Config entity.
// If the BackupS3Config object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupS3ConfigMutation) OldBucket(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucket is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucket requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucket: %w", err)
	}
	return oldValue.Bucket, nil
}

// ResetBucket resets all changes to the "bucket" field.
func (m *BackupS3ConfigMutation) ResetBucket() {
	m.bucket = nil
}

// SetAccessKeyID sets the "access_key_id" field.
func (m *BackupS3ConfigMutation) SetAccessKeyID(s string) {
	m.access_key_id = &s
}

// AccessKeyID returns the value of the "access_key_id" field in the mutation.
func (m *BackupS3ConfigMutation) AccessKeyID() (r string, exists bool) {
	v := m.access_key_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessKeyID returns the old "access_key_id" field's value of the BackupS3Config entity.
// If the BackupS3Config object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupS3ConfigMutation) OldAccessKeyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessKeyID: %w", err)
	}
	return oldValue.AccessKeyID, nil
}

// ResetAccessKeyID resets all changes to the "access_key_id" field.
func (m *BackupS3ConfigMutation) ResetAccessKeyID() {
	m.access_key_id = nil
}

// SetSecretAccessKeyEncrypted sets the "secret_access_key_encrypted" field.
func (m *BackupS3ConfigMutation) SetSecretAccessKeyEncrypted(s string) {
	m.secret_access_key_encrypted = &s
}

// SecretAccessKeyEncrypted returns the value of the "secret_access_key_encrypted" field in the mutation.
func (m *BackupS3ConfigMutation) SecretAccessKeyEncrypted() (r string, exists bool) {
	v := m.secret_access_key_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretAccessKeyEncrypted returns the old "secret_access_key_encrypted" field's value of the BackupS3Config entity.
// If the BackupS3Config object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupS3ConfigMutation) OldSecretAccessKeyEncrypted(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretAccessKeyEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretAccessKeyEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretAccessKeyEncrypted: %w", err)
	}
	return oldValue.SecretAccessKeyEncrypted, nil
}

// ClearSecretAccessKeyEncrypted clears the value of the "secret_access_key_encrypted" field.
func (m *BackupS3ConfigMutation) ClearSecretAccessKeyEncrypted() {
	m.secret_access_key_encrypted = nil
	m.clearedFields[backups3config.FieldSecretAccessKeyEncrypted] = struct{}{}
}

// SecretAccessKeyEncryptedCleared returns if the "secret_access_key_encrypted" field was cleared in this mutation.
func (m *BackupS3ConfigMutation) SecretAccessKeyEncryptedCleared() bool {
	_, ok := m.clearedFields[backups3config.FieldSecretAccessKeyEncrypted]
	return ok
}

// ResetSecretAccessKeyEncrypted resets all changes to the "secret_access_key_encrypted" field.
func (m *BackupS3ConfigMutation) ResetSecretAccessKeyEncrypted() {
	m.secret_access_key_encrypted = nil
	delete(m.clearedFields, backups3config.FieldSecretAccessKeyEncrypted)
}

// SetPrefix sets the "prefix" field.
func (m *BackupS3ConfigMutation) SetPrefix(s string) {
	m.prefix = &s
}

// Prefix returns the value of the "prefix" field in the mutation.
func (m *BackupS3ConfigMutation) Prefix() (r string, exists bool) {
	v := m.prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldPrefix returns the old "prefix" field's value of the BackupS3Config entity.
// If the BackupS3Config object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupS3ConfigMutation) OldPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrefix: %w", err)
	}
	return oldValue.Prefix, nil
}

// ResetPrefix resets all changes to the "prefix" field.
func (m *BackupS3ConfigMutation) ResetPrefix() {
	m.prefix = nil
}

// SetForcePathStyle sets the "force_path_style" field.
func (m *BackupS3ConfigMutation) SetForcePathStyle(b bool) {
	m.force_path_style = &b
}

// ForcePathStyle returns the value of the "force_path_style" field in the mutation.
func (m *BackupS3ConfigMutation) ForcePathStyle() (r bool, exists bool) {
	v := m.force_path_style
	if v == nil {
		return
	}
	return *v, true
}

// OldForcePathStyle returns the old "force_path_style" field's value of the BackupS3Config entity.
// If the BackupS3Config object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupS3ConfigMutation) OldForcePathStyle(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForcePathStyle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForcePathStyle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForcePathStyle: %w", err)
	}
	return oldValue.ForcePathStyle, nil
}

// ResetForcePathStyle resets all changes to the "force_path_style" field.
func (m *BackupS3ConfigMutation) ResetForcePathStyle() {
	m.force_path_style = nil
}

// SetUseSsl sets the "use_ssl" field.
func (m *BackupS3ConfigMutation) SetUseSsl(b bool) {
	m.use_ssl = &b
}

// UseSsl returns the value of the "use_ssl" field in the mutation.
func (m *BackupS3ConfigMutation) UseSsl() (r bool, exists bool) {
	v := m.use_ssl
	if v == nil {
		return
	}
	return *v, true
}

// OldUseSsl returns the old "use_ssl" field's value of the BackupS3Config entity.
// If the BackupS3Config object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupS3ConfigMutation) OldUseSsl(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseSsl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseSsl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseSsl: %w", err)
	}
	return oldValue.UseSsl, nil
}

// ResetUseSsl resets all changes to the "use_ssl" field.
func (m *BackupS3ConfigMutation) ResetUseSsl() {
	m.use_ssl = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BackupS3ConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BackupS3ConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BackupS3Config entity.
// If the BackupS3Config object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupS3ConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BackupS3ConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BackupS3ConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BackupS3ConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BackupS3Config entity.
// If the BackupS3Config object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupS3ConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BackupS3ConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the BackupS3ConfigMutation builder.
func (m *BackupS3ConfigMutation) Where(ps ...predicate.BackupS3Config) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BackupS3ConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BackupS3ConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BackupS3Config, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BackupS3ConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BackupS3ConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BackupS3Config).
func (m *BackupS3ConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BackupS3ConfigMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.profile_id != nil {
		fields = append(fields, backups3config.FieldProfileID)
	}
	if m.name != nil {
		fields = append(fields, backups3config.FieldName)
	}
	if m.is_active != nil {
		fields = append(fields, backups3config.FieldIsActive)
	}
	if m.enabled != nil {
		fields = append(fields, backups3config.FieldEnabled)
	}
	if m.endpoint != nil {
		fields = append(fields, backups3config.FieldEndpoint)
	}
	if m.region != nil {
		fields = append(fields, backups3config.FieldRegion)
	}
	if m.bucket != nil {
		fields = append(fields, backups3config.FieldBucket)
	}
	if m.access_key_id != nil {
		fields = append(fields, backups3config.FieldAccessKeyID)
	}
	if m.secret_access_key_encrypted != nil {
		fields = append(fields, backups3config.FieldSecretAccessKeyEncrypted)
	}
	if m.prefix != nil {
		fields = append(fields, backups3config.FieldPrefix)
	}
	if m.force_path_style != nil {
		fields = append(fields, backups3config.FieldForcePathStyle)
	}
	if m.use_ssl != nil {
		fields = append(fields, backups3config.FieldUseSsl)
	}
	if m.created_at != nil {
		fields = append(fields, backups3config.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, backups3config.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BackupS3ConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case backups3config.FieldProfileID:
		return m.ProfileID()
	case backups3config.FieldName:
		return m.Name()
	case backups3config.FieldIsActive:
		return m.IsActive()
	case backups3config.FieldEnabled:
		return m.Enabled()
	case backups3config.FieldEndpoint:
		return m.Endpoint()
	case backups3config.FieldRegion:
		return m.Region()
	case backups3config.FieldBucket:
		return m.Bucket()
	case backups3config.FieldAccessKeyID:
		return m.AccessKeyID()
	case backups3config.FieldSecretAccessKeyEncrypted:
		return m.SecretAccessKeyEncrypted()
	case backups3config.FieldPrefix:
		return m.Prefix()
	case backups3config.FieldForcePathStyle:
		return m.ForcePathStyle()
	case backups3config.FieldUseSsl:
		return m.UseSsl()
	case backups3config.FieldCreatedAt:
		return m.CreatedAt()
	case backups3config.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BackupS3ConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case backups3config.FieldProfileID:
		return m.OldProfileID(ctx)
	case backups3config.FieldName:
		return m.OldName(ctx)
	case backups3config.FieldIsActive:
		return m.OldIsActive(ctx)
	case backups3config.FieldEnabled:
		return m.OldEnabled(ctx)
	case backups3config.FieldEndpoint:
		return m.OldEndpoint(ctx)
	case backups3config.FieldRegion:
		return m.OldRegion(ctx)
	case backups3config.FieldBucket:
		return m.OldBucket(ctx)
	case backups3config.FieldAccessKeyID:
		return m.OldAccessKeyID(ctx)
	case backups3config.FieldSecretAccessKeyEncrypted:
		return m.OldSecretAccessKeyEncrypted(ctx)
	case backups3config.FieldPrefix:
		return m.OldPrefix(ctx)
	case backups3config.FieldForcePathStyle:
		return m.OldForcePathStyle(ctx)
	case backups3config.FieldUseSsl:
		return m.OldUseSsl(ctx)
	case backups3config.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case backups3config.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BackupS3Config field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackupS3ConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case backups3config.FieldProfileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileID(v)
		return nil
	case backups3config.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case backups3config.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case backups3config.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case backups3config.FieldEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndpoint(v)
		return nil
	case backups3config.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case backups3config.FieldBucket:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucket(v)
		return nil
	case backups3config.FieldAccessKeyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessKeyID(v)
		return nil
	case backups3config.FieldSecretAccessKeyEncrypted:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretAccessKeyEncrypted(v)
		return nil
	case backups3config.FieldPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrefix(v)
		return nil
	case backups3config.FieldForcePathStyle:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForcePathStyle(v)
		return nil
	case backups3config.FieldUseSsl:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseSsl(v)
		return nil
	case backups3config.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case backups3config.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BackupS3Config field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BackupS3ConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BackupS3ConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackupS3ConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BackupS3Config numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BackupS3ConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(backups3config.FieldSecretAccessKeyEncrypted) {
		fields = append(fields, backups3config.FieldSecretAccessKeyEncrypted)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BackupS3ConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BackupS3ConfigMutation) ClearField(name string) error {
	switch name {
	case backups3config.FieldSecretAccessKeyEncrypted:
		m.ClearSecretAccessKeyEncrypted()
		return nil
	}
	return fmt.Errorf("unknown BackupS3Config nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BackupS3ConfigMutation) ResetField(name string) error {
	switch name {
	case backups3config.FieldProfileID:
		m.ResetProfileID()
		return nil
	case backups3config.FieldName:
		m.ResetName()
		return nil
	case backups3config.FieldIsActive:
		m.ResetIsActive()
		return nil
	case backups3config.FieldEnabled:
		m.ResetEnabled()
		return nil
	case backups3config.FieldEndpoint:
		m.ResetEndpoint()
		return nil
	case backups3config.FieldRegion:
		m.ResetRegion()
		return nil
	case backups3config.FieldBucket:
		m.ResetBucket()
		return nil
	case backups3config.FieldAccessKeyID:
		m.ResetAccessKeyID()
		return nil
	case backups3config.FieldSecretAccessKeyEncrypted:
		m.ResetSecretAccessKeyEncrypted()
		return nil
	case backups3config.FieldPrefix:
		m.ResetPrefix()
		return nil
	case backups3config.FieldForcePathStyle:
		m.ResetForcePathStyle()
		return nil
	case backups3config.FieldUseSsl:
		m.ResetUseSsl()
		return nil
	case backups3config.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case backups3config.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BackupS3Config field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BackupS3ConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BackupS3ConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BackupS3ConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BackupS3ConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BackupS3ConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BackupS3ConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BackupS3ConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BackupS3Config unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BackupS3ConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BackupS3Config edge %s", name)
}

// BackupSettingMutation represents an operation that mutates the BackupSetting nodes in the graph.
type BackupSettingMutation struct {
	config
	op                Op
	typ               string
	id                *int
	source_mode       *backupsetting.SourceMode
	backup_root       *string
	retention_days    *int
	addretention_days *int
	keep_last         *int
	addkeep_last      *int
	sqlite_path       *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*BackupSetting, error)
	predicates        []predicate.BackupSetting
}

var _ ent.Mutation = (*BackupSettingMutation)(nil)

// backupsettingOption allows management of the mutation configuration using functional options.
type backupsettingOption func(*BackupSettingMutation)

// newBackupSettingMutation creates new mutation for the BackupSetting entity.
func newBackupSettingMutation(c config, op Op, opts ...backupsettingOption) *BackupSettingMutation {
	m := &BackupSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeBackupSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBackupSettingID sets the ID field of the mutation.
func withBackupSettingID(id int) backupsettingOption {
	return func(m *BackupSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *BackupSetting
		)
		m.oldValue = func(ctx context.Context) (*BackupSetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BackupSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBackupSetting sets the old BackupSetting of the mutation.
func withBackupSetting(node *BackupSetting) backupsettingOption {
	return func(m *BackupSettingMutation) {
		m.oldValue = func(context.Context) (*BackupSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BackupSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BackupSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BackupSettingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BackupSettingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BackupSetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSourceMode sets the "source_mode" field.
func (m *BackupSettingMutation) SetSourceMode(bm backupsetting.SourceMode) {
	m.source_mode = &bm
}

// SourceMode returns the value of the "source_mode" field in the mutation.
func (m *BackupSettingMutation) SourceMode() (r backupsetting.SourceMode, exists bool) {
	v := m.source_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceMode returns the old "source_mode" field's value of the BackupSetting entity.
// If the BackupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSettingMutation) OldSourceMode(ctx context.Context) (v backupsetting.SourceMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceMode: %w", err)
	}
	return oldValue.SourceMode, nil
}

// ResetSourceMode resets all changes to the "source_mode" field.
func (m *BackupSettingMutation) ResetSourceMode() {
	m.source_mode = nil
}

// SetBackupRoot sets the "backup_root" field.
func (m *BackupSettingMutation) SetBackupRoot(s string) {
	m.backup_root = &s
}

// BackupRoot returns the value of the "backup_root" field in the mutation.
func (m *BackupSettingMutation) BackupRoot() (r string, exists bool) {
	v := m.backup_root
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupRoot returns the old "backup_root" field's value of the BackupSetting entity.
// If the BackupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSettingMutation) OldBackupRoot(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupRoot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupRoot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupRoot: %w", err)
	}
	return oldValue.BackupRoot, nil
}

// ResetBackupRoot resets all changes to the "backup_root" field.
func (m *BackupSettingMutation) ResetBackupRoot() {
	m.backup_root = nil
}

// SetRetentionDays sets the "retention_days" field.
func (m *BackupSettingMutation) SetRetentionDays(i int) {
	m.retention_days = &i
	m.addretention_days = nil
}

// RetentionDays returns the value of the "retention_days" field in the mutation.
func (m *BackupSettingMutation) RetentionDays() (r int, exists bool) {
	v := m.retention_days
	if v == nil {
		return
	}
	return *v, true
}

// OldRetentionDays returns the old "retention_days" field's value of the BackupSetting entity.
// If the BackupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSettingMutation) OldRetentionDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetentionDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetentionDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetentionDays: %w", err)
	}
	return oldValue.RetentionDays, nil
}

// AddRetentionDays adds i to the "retention_days" field.
func (m *BackupSettingMutation) AddRetentionDays(i int) {
	if m.addretention_days != nil {
		*m.addretention_days += i
	} else {
		m.addretention_days = &i
	}
}

// AddedRetentionDays returns the value that was added to the "retention_days" field in this mutation.
func (m *BackupSettingMutation) AddedRetentionDays() (r int, exists bool) {
	v := m.addretention_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetentionDays resets all changes to the "retention_days" field.
func (m *BackupSettingMutation) ResetRetentionDays() {
	m.retention_days = nil
	m.addretention_days = nil
}

// SetKeepLast sets the "keep_last" field.
func (m *BackupSettingMutation) SetKeepLast(i int) {
	m.keep_last = &i
	m.addkeep_last = nil
}

// KeepLast returns the value of the "keep_last" field in the mutation.
func (m *BackupSettingMutation) KeepLast() (r int, exists bool) {
	v := m.keep_last
	if v == nil {
		return
	}
	return *v, true
}

// OldKeepLast returns the old "keep_last" field's value of the BackupSetting entity.
// If the BackupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSettingMutation) OldKeepLast(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeepLast is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeepLast requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeepLast: %w", err)
	}
	return oldValue.KeepLast, nil
}

// AddKeepLast adds i to the "keep_last" field.
func (m *BackupSettingMutation) AddKeepLast(i int) {
	if m.addkeep_last != nil {
		*m.addkeep_last += i
	} else {
		m.addkeep_last = &i
	}
}

// AddedKeepLast returns the value that was added to the "keep_last" field in this mutation.
func (m *BackupSettingMutation) AddedKeepLast() (r int, exists bool) {
	v := m.addkeep_last
	if v == nil {
		return
	}
	return *v, true
}

// ResetKeepLast resets all changes to the "keep_last" field.
func (m *BackupSettingMutation) ResetKeepLast() {
	m.keep_last = nil
	m.addkeep_last = nil
}

// SetSqlitePath sets the "sqlite_path" field.
func (m *BackupSettingMutation) SetSqlitePath(s string) {
	m.sqlite_path = &s
}

// SqlitePath returns the value of the "sqlite_path" field in the mutation.
func (m *BackupSettingMutation) SqlitePath() (r string, exists bool) {
	v := m.sqlite_path
	if v == nil {
		return
	}
	return *v, true
}

// OldSqlitePath returns the old "sqlite_path" field's value of the BackupSetting entity.
// If the BackupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSettingMutation) OldSqlitePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSqlitePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSqlitePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSqlitePath: %w", err)
	}
	return oldValue.SqlitePath, nil
}

// ResetSqlitePath resets all changes to the "sqlite_path" field.
func (m *BackupSettingMutation) ResetSqlitePath() {
	m.sqlite_path = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BackupSettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BackupSettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BackupSetting entity.
// If the BackupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BackupSettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BackupSettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BackupSettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BackupSetting entity.
// If the BackupSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BackupSettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the BackupSettingMutation builder.
func (m *BackupSettingMutation) Where(ps ...predicate.BackupSetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BackupSettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BackupSettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BackupSetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BackupSettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BackupSettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BackupSetting).
func (m *BackupSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BackupSettingMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.source_mode != nil {
		fields = append(fields, backupsetting.FieldSourceMode)
	}
	if m.backup_root != nil {
		fields = append(fields, backupsetting.FieldBackupRoot)
	}
	if m.retention_days != nil {
		fields = append(fields, backupsetting.FieldRetentionDays)
	}
	if m.keep_last != nil {
		fields = append(fields, backupsetting.FieldKeepLast)
	}
	if m.sqlite_path != nil {
		fields = append(fields, backupsetting.FieldSqlitePath)
	}
	if m.created_at != nil {
		fields = append(fields, backupsetting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, backupsetting.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BackupSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case backupsetting.FieldSourceMode:
		return m.SourceMode()
	case backupsetting.FieldBackupRoot:
		return m.BackupRoot()
	case backupsetting.FieldRetentionDays:
		return m.RetentionDays()
	case backupsetting.FieldKeepLast:
		return m.KeepLast()
	case backupsetting.FieldSqlitePath:
		return m.SqlitePath()
	case backupsetting.FieldCreatedAt:
		return m.CreatedAt()
	case backupsetting.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BackupSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case backupsetting.FieldSourceMode:
		return m.OldSourceMode(ctx)
	case backupsetting.FieldBackupRoot:
		return m.OldBackupRoot(ctx)
	case backupsetting.FieldRetentionDays:
		return m.OldRetentionDays(ctx)
	case backupsetting.FieldKeepLast:
		return m.OldKeepLast(ctx)
	case backupsetting.FieldSqlitePath:
		return m.OldSqlitePath(ctx)
	case backupsetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case backupsetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BackupSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackupSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case backupsetting.FieldSourceMode:
		v, ok := value.(backupsetting.SourceMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceMode(v)
		return nil
	case backupsetting.FieldBackupRoot:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupRoot(v)
		return nil
	case backupsetting.FieldRetentionDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetentionDays(v)
		return nil
	case backupsetting.FieldKeepLast:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeepLast(v)
		return nil
	case backupsetting.FieldSqlitePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSqlitePath(v)
		return nil
	case backupsetting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case backupsetting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BackupSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BackupSettingMutation) AddedFields() []string {
	var fields []string
	if m.addretention_days != nil {
		fields = append(fields, backupsetting.FieldRetentionDays)
	}
	if m.addkeep_last != nil {
		fields = append(fields, backupsetting.FieldKeepLast)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BackupSettingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case backupsetting.FieldRetentionDays:
		return m.AddedRetentionDays()
	case backupsetting.FieldKeepLast:
		return m.AddedKeepLast()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackupSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case backupsetting.FieldRetentionDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetentionDays(v)
		return nil
	case backupsetting.FieldKeepLast:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKeepLast(v)
		return nil
	}
	return fmt.Errorf("unknown BackupSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BackupSettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BackupSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BackupSettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BackupSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BackupSettingMutation) ResetField(name string) error {
	switch name {
	case backupsetting.FieldSourceMode:
		m.ResetSourceMode()
		return nil
	case backupsetting.FieldBackupRoot:
		m.ResetBackupRoot()
		return nil
	case backupsetting.FieldRetentionDays:
		m.ResetRetentionDays()
		return nil
	case backupsetting.FieldKeepLast:
		m.ResetKeepLast()
		return nil
	case backupsetting.FieldSqlitePath:
		m.ResetSqlitePath()
		return nil
	case backupsetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case backupsetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BackupSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BackupSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BackupSettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BackupSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BackupSettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BackupSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BackupSettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BackupSettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BackupSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BackupSettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BackupSetting edge %s", name)
}

// BackupSourceConfigMutation represents an operation that mutates the BackupSourceConfig nodes in the graph.
type BackupSourceConfigMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	source_type        *backupsourceconfig.SourceType
	profile_id         *string
	name               *string
	is_active          *bool
	host               *string
	port               *int
	addport            *int
	username           *string
	password_encrypted *string
	database           *string
	ssl_mode           *string
	addr               *string
	redis_db           *int
	addredis_db        *int
	container_name     *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*BackupSourceConfig, error)
	predicates         []predicate.BackupSourceConfig
}

var _ ent.Mutation = (*BackupSourceConfigMutation)(nil)

// backupsourceconfigOption allows management of the mutation configuration using functional options.
type backupsourceconfigOption func(*BackupSourceConfigMutation)

// newBackupSourceConfigMutation creates new mutation for the BackupSourceConfig entity.
func newBackupSourceConfigMutation(c config, op Op, opts ...backupsourceconfigOption) *BackupSourceConfigMutation {
	m := &BackupSourceConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeBackupSourceConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBackupSourceConfigID sets the ID field of the mutation.
func withBackupSourceConfigID(id int) backupsourceconfigOption {
	return func(m *BackupSourceConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *BackupSourceConfig
		)
		m.oldValue = func(ctx context.Context) (*BackupSourceConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BackupSourceConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBackupSourceConfig sets the old BackupSourceConfig of the mutation.
func withBackupSourceConfig(node *BackupSourceConfig) backupsourceconfigOption {
	return func(m *BackupSourceConfigMutation) {
		m.oldValue = func(context.Context) (*BackupSourceConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BackupSourceConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BackupSourceConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BackupSourceConfigMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BackupSourceConfigMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BackupSourceConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSourceType sets the "source_type" field.
func (m *BackupSourceConfigMutation) SetSourceType(bt backupsourceconfig.SourceType) {
	m.source_type = &bt
}

// SourceType returns the value of the "source_type" field in the mutation.
func (m *BackupSourceConfigMutation) SourceType() (r backupsourceconfig.SourceType, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old "source_type" field's value of the BackupSourceConfig entity.
// If the BackupSourceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSourceConfigMutation) OldSourceType(ctx context.Context) (v backupsourceconfig.SourceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ResetSourceType resets all changes to the "source_type" field.
func (m *BackupSourceConfigMutation) ResetSourceType() {
	m.source_type = nil
}

// SetProfileID sets the "profile_id" field.
func (m *BackupSourceConfigMutation) SetProfileID(s string) {
	m.profile_id = &s
}

// ProfileID returns the value of the "profile_id" field in the mutation.
func (m *BackupSourceConfigMutation) ProfileID() (r string, exists bool) {
	v := m.profile_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileID returns the old "profile_id" field's value of the BackupSourceConfig entity.
// If the BackupSourceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSourceConfigMutation) OldProfileID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileID: %w", err)
	}
	return oldValue.ProfileID, nil
}

// ResetProfileID resets all changes to the "profile_id" field.
func (m *BackupSourceConfigMutation) ResetProfileID() {
	m.profile_id = nil
}

// SetName sets the "name" field.
func (m *BackupSourceConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BackupSourceConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BackupSourceConfig entity.
// If the BackupSourceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSourceConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BackupSourceConfigMutation) ResetName() {
	m.name = nil
}

// SetIsActive sets the "is_active" field.
func (m *BackupSourceConfigMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *BackupSourceConfigMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the BackupSourceConfig entity.
// If the BackupSourceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSourceConfigMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *BackupSourceConfigMutation) ResetIsActive() {
	m.is_active = nil
}

// SetHost sets the "host" field.
func (m *BackupSourceConfigMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *BackupSourceConfigMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the BackupSourceConfig entity.
// If the BackupSourceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSourceConfigMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ClearHost clears the value of the "host" field.
func (m *BackupSourceConfigMutation) ClearHost() {
	m.host = nil
	m.clearedFields[backupsourceconfig.FieldHost] = struct{}{}
}

// HostCleared returns if the "host" field was cleared in this mutation.
func (m *BackupSourceConfigMutation) HostCleared() bool {
	_, ok := m.clearedFields[backupsourceconfig.FieldHost]
	return ok
}

// ResetHost resets all changes to the "host" field.
func (m *BackupSourceConfigMutation) ResetHost() {
	m.host = nil
	delete(m.clearedFields, backupsourceconfig.FieldHost)
}

// SetPort sets the "port" field.
func (m *BackupSourceConfigMutation) SetPort(i int) {
	m.port = &i
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *BackupSourceConfigMutation) Port() (r int, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the BackupSourceConfig entity.
// If the BackupSourceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSourceConfigMutation) OldPort(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to the "port" field.
func (m *BackupSourceConfigMutation) AddPort(i int) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *BackupSourceConfigMutation) AddedPort() (r int, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ClearPort clears the value of the "port" field.
func (m *BackupSourceConfigMutation) ClearPort() {
	m.port = nil
	m.addport = nil
	m.clearedFields[backupsourceconfig.FieldPort] = struct{}{}
}

// PortCleared returns if the "port" field was cleared in this mutation.
func (m *BackupSourceConfigMutation) PortCleared() bool {
	_, ok := m.clearedFields[backupsourceconfig.FieldPort]
	return ok
}

// ResetPort resets all changes to the "port" field.
func (m *BackupSourceConfigMutation) ResetPort() {
	m.port = nil
	m.addport = nil
	delete(m.clearedFields, backupsourceconfig.FieldPort)
}

// SetUsername sets the "username" field.
func (m *BackupSourceConfigMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *BackupSourceConfigMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the BackupSourceConfig entity.
// If the BackupSourceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSourceConfigMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *BackupSourceConfigMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[backupsourceconfig.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *BackupSourceConfigMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[backupsourceconfig.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *BackupSourceConfigMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, backupsourceconfig.FieldUsername)
}

// SetPasswordEncrypted sets the "password_encrypted" field.
func (m *BackupSourceConfigMutation) SetPasswordEncrypted(s string) {
	m.password_encrypted = &s
}

// PasswordEncrypted returns the value of the "password_encrypted" field in the mutation.
func (m *BackupSourceConfigMutation) PasswordEncrypted() (r string, exists bool) {
	v := m.password_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordEncrypted returns the old "password_encrypted" field's value of the BackupSourceConfig entity.
// If the BackupSourceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSourceConfigMutation) OldPasswordEncrypted(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordEncrypted: %w", err)
	}
	return oldValue.PasswordEncrypted, nil
}

// ClearPasswordEncrypted clears the value of the "password_encrypted" field.
func (m *BackupSourceConfigMutation) ClearPasswordEncrypted() {
	m.password_encrypted = nil
	m.clearedFields[backupsourceconfig.FieldPasswordEncrypted] = struct{}{}
}

// PasswordEncryptedCleared returns if the "password_encrypted" field was cleared in this mutation.
func (m *BackupSourceConfigMutation) PasswordEncryptedCleared() bool {
	_, ok := m.clearedFields[backupsourceconfig.FieldPasswordEncrypted]
	return ok
}

// ResetPasswordEncrypted resets all changes to the "password_encrypted" field.
func (m *BackupSourceConfigMutation) ResetPasswordEncrypted() {
	m.password_encrypted = nil
	delete(m.clearedFields, backupsourceconfig.FieldPasswordEncrypted)
}

// SetDatabase sets the "database" field.
func (m *BackupSourceConfigMutation) SetDatabase(s string) {
	m.database = &s
}

// Database returns the value of the "database" field in the mutation.
func (m *BackupSourceConfigMutation) Database() (r string, exists bool) {
	v := m.database
	if v == nil {
		return
	}
	return *v, true
}

// OldDatabase returns the old "database" field's value of the BackupSourceConfig entity.
// If the BackupSourceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSourceConfigMutation) OldDatabase(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatabase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatabase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatabase: %w", err)
	}
	return oldValue.Database, nil
}

// ClearDatabase clears the value of the "database" field.
func (m *BackupSourceConfigMutation) ClearDatabase() {
	m.database = nil
	m.clearedFields[backupsourceconfig.FieldDatabase] = struct{}{}
}

// DatabaseCleared returns if the "database" field was cleared in this mutation.
func (m *BackupSourceConfigMutation) DatabaseCleared() bool {
	_, ok := m.clearedFields[backupsourceconfig.FieldDatabase]
	return ok
}

// ResetDatabase resets all changes to the "database" field.
func (m *BackupSourceConfigMutation) ResetDatabase() {
	m.database = nil
	delete(m.clearedFields, backupsourceconfig.FieldDatabase)
}

// SetSslMode sets the "ssl_mode" field.
func (m *BackupSourceConfigMutation) SetSslMode(s string) {
	m.ssl_mode = &s
}

// SslMode returns the value of the "ssl_mode" field in the mutation.
func (m *BackupSourceConfigMutation) SslMode() (r string, exists bool) {
	v := m.ssl_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldSslMode returns the old "ssl_mode" field's value of the BackupSourceConfig entity.
// If the BackupSourceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSourceConfigMutation) OldSslMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSslMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSslMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSslMode: %w", err)
	}
	return oldValue.SslMode, nil
}

// ClearSslMode clears the value of the "ssl_mode" field.
func (m *BackupSourceConfigMutation) ClearSslMode() {
	m.ssl_mode = nil
	m.clearedFields[backupsourceconfig.FieldSslMode] = struct{}{}
}

// SslModeCleared returns if the "ssl_mode" field was cleared in this mutation.
func (m *BackupSourceConfigMutation) SslModeCleared() bool {
	_, ok := m.clearedFields[backupsourceconfig.FieldSslMode]
	return ok
}

// ResetSslMode resets all changes to the "ssl_mode" field.
func (m *BackupSourceConfigMutation) ResetSslMode() {
	m.ssl_mode = nil
	delete(m.clearedFields, backupsourceconfig.FieldSslMode)
}

// SetAddr sets the "addr" field.
func (m *BackupSourceConfigMutation) SetAddr(s string) {
	m.addr = &s
}

// Addr returns the value of the "addr" field in the mutation.
func (m *BackupSourceConfigMutation) Addr() (r string, exists bool) {
	v := m.addr
	if v == nil {
		return
	}
	return *v, true
}

// OldAddr returns the old "addr" field's value of the BackupSourceConfig entity.
// If the BackupSourceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSourceConfigMutation) OldAddr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddr: %w", err)
	}
	return oldValue.Addr, nil
}

// ClearAddr clears the value of the "addr" field.
func (m *BackupSourceConfigMutation) ClearAddr() {
	m.addr = nil
	m.clearedFields[backupsourceconfig.FieldAddr] = struct{}{}
}

// AddrCleared returns if the "addr" field was cleared in this mutation.
func (m *BackupSourceConfigMutation) AddrCleared() bool {
	_, ok := m.clearedFields[backupsourceconfig.FieldAddr]
	return ok
}

// ResetAddr resets all changes to the "addr" field.
func (m *BackupSourceConfigMutation) ResetAddr() {
	m.addr = nil
	delete(m.clearedFields, backupsourceconfig.FieldAddr)
}

// SetRedisDb sets the "redis_db" field.
func (m *BackupSourceConfigMutation) SetRedisDb(i int) {
	m.redis_db = &i
	m.addredis_db = nil
}

// RedisDb returns the value of the "redis_db" field in the mutation.
func (m *BackupSourceConfigMutation) RedisDb() (r int, exists bool) {
	v := m.redis_db
	if v == nil {
		return
	}
	return *v, true
}

// OldRedisDb returns the old "redis_db" field's value of the BackupSourceConfig entity.
// If the BackupSourceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSourceConfigMutation) OldRedisDb(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedisDb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedisDb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedisDb: %w", err)
	}
	return oldValue.RedisDb, nil
}

// AddRedisDb adds i to the "redis_db" field.
func (m *BackupSourceConfigMutation) AddRedisDb(i int) {
	if m.addredis_db != nil {
		*m.addredis_db += i
	} else {
		m.addredis_db = &i
	}
}

// AddedRedisDb returns the value that was added to the "redis_db" field in this mutation.
func (m *BackupSourceConfigMutation) AddedRedisDb() (r int, exists bool) {
	v := m.addredis_db
	if v == nil {
		return
	}
	return *v, true
}

// ClearRedisDb clears the value of the "redis_db" field.
func (m *BackupSourceConfigMutation) ClearRedisDb() {
	m.redis_db = nil
	m.addredis_db = nil
	m.clearedFields[backupsourceconfig.FieldRedisDb] = struct{}{}
}

// RedisDbCleared returns if the "redis_db" field was cleared in this mutation.
func (m *BackupSourceConfigMutation) RedisDbCleared() bool {
	_, ok := m.clearedFields[backupsourceconfig.FieldRedisDb]
	return ok
}

// ResetRedisDb resets all changes to the "redis_db" field.
func (m *BackupSourceConfigMutation) ResetRedisDb() {
	m.redis_db = nil
	m.addredis_db = nil
	delete(m.clearedFields, backupsourceconfig.FieldRedisDb)
}

// SetContainerName sets the "container_name" field.
func (m *BackupSourceConfigMutation) SetContainerName(s string) {
	m.container_name = &s
}

// ContainerName returns the value of the "container_name" field in the mutation.
func (m *BackupSourceConfigMutation) ContainerName() (r string, exists bool) {
	v := m.container_name
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerName returns the old "container_name" field's value of the BackupSourceConfig entity.
// If the BackupSourceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSourceConfigMutation) OldContainerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerName: %w", err)
	}
	return oldValue.ContainerName, nil
}

// ResetContainerName resets all changes to the "container_name" field.
func (m *BackupSourceConfigMutation) ResetContainerName() {
	m.container_name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BackupSourceConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BackupSourceConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BackupSourceConfig entity.
// If the BackupSourceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSourceConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BackupSourceConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BackupSourceConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BackupSourceConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BackupSourceConfig entity.
// If the BackupSourceConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BackupSourceConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BackupSourceConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the BackupSourceConfigMutation builder.
func (m *BackupSourceConfigMutation) Where(ps ...predicate.BackupSourceConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BackupSourceConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BackupSourceConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BackupSourceConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BackupSourceConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BackupSourceConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BackupSourceConfig).
func (m *BackupSourceConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BackupSourceConfigMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.source_type != nil {
		fields = append(fields, backupsourceconfig.FieldSourceType)
	}
	if m.profile_id != nil {
		fields = append(fields, backupsourceconfig.FieldProfileID)
	}
	if m.name != nil {
		fields = append(fields, backupsourceconfig.FieldName)
	}
	if m.is_active != nil {
		fields = append(fields, backupsourceconfig.FieldIsActive)
	}
	if m.host != nil {
		fields = append(fields, backupsourceconfig.FieldHost)
	}
	if m.port != nil {
		fields = append(fields, backupsourceconfig.FieldPort)
	}
	if m.username != nil {
		fields = append(fields, backupsourceconfig.FieldUsername)
	}
	if m.password_encrypted != nil {
		fields = append(fields, backupsourceconfig.FieldPasswordEncrypted)
	}
	if m.database != nil {
		fields = append(fields, backupsourceconfig.FieldDatabase)
	}
	if m.ssl_mode != nil {
		fields = append(fields, backupsourceconfig.FieldSslMode)
	}
	if m.addr != nil {
		fields = append(fields, backupsourceconfig.FieldAddr)
	}
	if m.redis_db != nil {
		fields = append(fields, backupsourceconfig.FieldRedisDb)
	}
	if m.container_name != nil {
		fields = append(fields, backupsourceconfig.FieldContainerName)
	}
	if m.created_at != nil {
		fields = append(fields, backupsourceconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, backupsourceconfig.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BackupSourceConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case backupsourceconfig.FieldSourceType:
		return m.SourceType()
	case backupsourceconfig.FieldProfileID:
		return m.ProfileID()
	case backupsourceconfig.FieldName:
		return m.Name()
	case backupsourceconfig.FieldIsActive:
		return m.IsActive()
	case backupsourceconfig.FieldHost:
		return m.Host()
	case backupsourceconfig.FieldPort:
		return m.Port()
	case backupsourceconfig.FieldUsername:
		return m.Username()
	case backupsourceconfig.FieldPasswordEncrypted:
		return m.PasswordEncrypted()
	case backupsourceconfig.FieldDatabase:
		return m.Database()
	case backupsourceconfig.FieldSslMode:
		return m.SslMode()
	case backupsourceconfig.FieldAddr:
		return m.Addr()
	case backupsourceconfig.FieldRedisDb:
		return m.RedisDb()
	case backupsourceconfig.FieldContainerName:
		return m.ContainerName()
	case backupsourceconfig.FieldCreatedAt:
		return m.CreatedAt()
	case backupsourceconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BackupSourceConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case backupsourceconfig.FieldSourceType:
		return m.OldSourceType(ctx)
	case backupsourceconfig.FieldProfileID:
		return m.OldProfileID(ctx)
	case backupsourceconfig.FieldName:
		return m.OldName(ctx)
	case backupsourceconfig.FieldIsActive:
		return m.OldIsActive(ctx)
	case backupsourceconfig.FieldHost:
		return m.OldHost(ctx)
	case backupsourceconfig.FieldPort:
		return m.OldPort(ctx)
	case backupsourceconfig.FieldUsername:
		return m.OldUsername(ctx)
	case backupsourceconfig.FieldPasswordEncrypted:
		return m.OldPasswordEncrypted(ctx)
	case backupsourceconfig.FieldDatabase:
		return m.OldDatabase(ctx)
	case backupsourceconfig.FieldSslMode:
		return m.OldSslMode(ctx)
	case backupsourceconfig.FieldAddr:
		return m.OldAddr(ctx)
	case backupsourceconfig.FieldRedisDb:
		return m.OldRedisDb(ctx)
	case backupsourceconfig.FieldContainerName:
		return m.OldContainerName(ctx)
	case backupsourceconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case backupsourceconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BackupSourceConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackupSourceConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case backupsourceconfig.FieldSourceType:
		v, ok := value.(backupsourceconfig.SourceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case backupsourceconfig.FieldProfileID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileID(v)
		return nil
	case backupsourceconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case backupsourceconfig.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case backupsourceconfig.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case backupsourceconfig.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case backupsourceconfig.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case backupsourceconfig.FieldPasswordEncrypted:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordEncrypted(v)
		return nil
	case backupsourceconfig.FieldDatabase:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatabase(v)
		return nil
	case backupsourceconfig.FieldSslMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSslMode(v)
		return nil
	case backupsourceconfig.FieldAddr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddr(v)
		return nil
	case backupsourceconfig.FieldRedisDb:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedisDb(v)
		return nil
	case backupsourceconfig.FieldContainerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerName(v)
		return nil
	case backupsourceconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case backupsourceconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BackupSourceConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BackupSourceConfigMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, backupsourceconfig.FieldPort)
	}
	if m.addredis_db != nil {
		fields = append(fields, backupsourceconfig.FieldRedisDb)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BackupSourceConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case backupsourceconfig.FieldPort:
		return m.AddedPort()
	case backupsourceconfig.FieldRedisDb:
		return m.AddedRedisDb()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BackupSourceConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case backupsourceconfig.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	case backupsourceconfig.FieldRedisDb:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRedisDb(v)
		return nil
	}
	return fmt.Errorf("unknown BackupSourceConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BackupSourceConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(backupsourceconfig.FieldHost) {
		fields = append(fields, backupsourceconfig.FieldHost)
	}
	if m.FieldCleared(backupsourceconfig.FieldPort) {
		fields = append(fields, backupsourceconfig.FieldPort)
	}
	if m.FieldCleared(backupsourceconfig.FieldUsername) {
		fields = append(fields, backupsourceconfig.FieldUsername)
	}
	if m.FieldCleared(backupsourceconfig.FieldPasswordEncrypted) {
		fields = append(fields, backupsourceconfig.FieldPasswordEncrypted)
	}
	if m.FieldCleared(backupsourceconfig.FieldDatabase) {
		fields = append(fields, backupsourceconfig.FieldDatabase)
	}
	if m.FieldCleared(backupsourceconfig.FieldSslMode) {
		fields = append(fields, backupsourceconfig.FieldSslMode)
	}
	if m.FieldCleared(backupsourceconfig.FieldAddr) {
		fields = append(fields, backupsourceconfig.FieldAddr)
	}
	if m.FieldCleared(backupsourceconfig.FieldRedisDb) {
		fields = append(fields, backupsourceconfig.FieldRedisDb)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BackupSourceConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BackupSourceConfigMutation) ClearField(name string) error {
	switch name {
	case backupsourceconfig.FieldHost:
		m.ClearHost()
		return nil
	case backupsourceconfig.FieldPort:
		m.ClearPort()
		return nil
	case backupsourceconfig.FieldUsername:
		m.ClearUsername()
		return nil
	case backupsourceconfig.FieldPasswordEncrypted:
		m.ClearPasswordEncrypted()
		return nil
	case backupsourceconfig.FieldDatabase:
		m.ClearDatabase()
		return nil
	case backupsourceconfig.FieldSslMode:
		m.ClearSslMode()
		return nil
	case backupsourceconfig.FieldAddr:
		m.ClearAddr()
		return nil
	case backupsourceconfig.FieldRedisDb:
		m.ClearRedisDb()
		return nil
	}
	return fmt.Errorf("unknown BackupSourceConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BackupSourceConfigMutation) ResetField(name string) error {
	switch name {
	case backupsourceconfig.FieldSourceType:
		m.ResetSourceType()
		return nil
	case backupsourceconfig.FieldProfileID:
		m.ResetProfileID()
		return nil
	case backupsourceconfig.FieldName:
		m.ResetName()
		return nil
	case backupsourceconfig.FieldIsActive:
		m.ResetIsActive()
		return nil
	case backupsourceconfig.FieldHost:
		m.ResetHost()
		return nil
	case backupsourceconfig.FieldPort:
		m.ResetPort()
		return nil
	case backupsourceconfig.FieldUsername:
		m.ResetUsername()
		return nil
	case backupsourceconfig.FieldPasswordEncrypted:
		m.ResetPasswordEncrypted()
		return nil
	case backupsourceconfig.FieldDatabase:
		m.ResetDatabase()
		return nil
	case backupsourceconfig.FieldSslMode:
		m.ResetSslMode()
		return nil
	case backupsourceconfig.FieldAddr:
		m.ResetAddr()
		return nil
	case backupsourceconfig.FieldRedisDb:
		m.ResetRedisDb()
		return nil
	case backupsourceconfig.FieldContainerName:
		m.ResetContainerName()
		return nil
	case backupsourceconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case backupsourceconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BackupSourceConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BackupSourceConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BackupSourceConfigMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BackupSourceConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BackupSourceConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BackupSourceConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BackupSourceConfigMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BackupSourceConfigMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BackupSourceConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BackupSourceConfigMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BackupSourceConfig edge %s", name)
}
